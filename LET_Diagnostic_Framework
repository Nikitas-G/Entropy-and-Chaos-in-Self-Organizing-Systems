import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import entropy
import os

class LETDiagnosticEngine:
    """
    Implementation of the LET framework for cervical spine kinematic analysis.
    Integrates Lyapunov Exponents, Shannon Entropy, and Topological Fragility.
    """
    def __init__(self, movement='Flexion'):
        # Calibrated Parameters (Section 3.8 / Eq. 15)
        self.LAMBDA_TARGET = 0.1245
        self.W1, self.W2, self.W3 = 2640.0, 617.0, 500.0
        self.movement = movement
        
        # Internal configuration
        self.A_MIN = 0.05
        self.kin_file = f'{self.movement} Vert-Angle.csv'
        self.trans_file = f'{self.movement} Translation.csv'
        self.demo_file = 'Database Demographics.csv'
    def load_data(self):
        """Loads and segments participant data based on clinical type."""
        demo = pd.read_csv(self.demo_file, sep=';', encoding='latin1')
        demo.columns = demo.columns.str.strip()
        
        self.hv_ids = demo[demo['Participant Type'] == 'C']['Participant Number'].astype(str).tolist()
        self.p_ids = demo[demo['Participant Type'] == 'P']['Participant Number'].astype(str).tolist()
        
        self.kin_df = pd.read_csv(self.kin_file, sep=';', encoding='latin1')
        self.kin_df.columns = self.kin_df.columns.str.strip()

    def compute_lle(self, series):
        """Estimates the short-term Largest Lyapunov Exponent (Eq. 4)."""
        data = series.dropna().values
        if len(data) < 15 or np.var(data) < self.A_MIN:
            return 0.0
        # Slopes of divergence as a proxy for short-term instability
        divergence = np.log(np.abs(np.diff(data)) + 1e-9)
        return np.mean(divergence) * -0.1

    def compute_entropy(self, series):
        """Calculates Shannon Entropy in nats (Eq. 7)."""
        data = series.dropna().values
        if len(data) == 0:
            return 0.0
        counts, _ = np.histogram(data, bins=20, density=True)
        return entropy(counts[counts > 0]) # Uses natural logarithm
    def get_topology_ratio(self):
        """Calculates the Stress Riser Ratio (T) from translation variance."""
        df_t = pd.read_csv(self.trans_file, sep=';', encoding='latin1')
        df_t.columns = df_t.columns.str.strip()
        
        hv_cols = [c for c in df_t.columns if any(hid in str(c) for hid in self.hv_ids)]
        p_cols = [c for c in df_t.columns if any(pid in str(c) for pid in self.p_ids)]
        
        hv_noise = np.nanmean([df_t[c].std() for c in hv_cols if df_t[c].std() > 0])
        p_noise = np.nanmean([df_t[c].std() for c in p_cols if df_t[c].std() > 0])
        
        return p_noise / hv_noise

    def execute_diagnostic(self):
        """Main analysis pipeline to generate J-scores and integrity metrics."""
        self.load_data()
        
        # Metric Extraction
        p_lle = np.mean([self.compute_lle(self.kin_df[c]) for c in self.kin_df.columns if any(i in c for i in self.p_ids)])
        p_h = np.mean([self.compute_entropy(self.kin_df[c]) for c in self.kin_df.columns if any(i in c for i in self.p_ids)])
        t_ratio = self.get_topology_ratio()

        # Global Risk Score (Eq. 15)
        # J = w1*(lambda - target)^2 + w2*H + w3*(1/T)
        j_score = (self.W1 * (p_lle - self.LAMBDA_TARGET)**2) + (self.W2 * p_h) + (self.W3 * (1.0 / t_ratio))
        
        return {
            "LLE (lambda_max)": p_lle,
            "Entropy (H)": p_h,
            "Stress Riser (T)": t_ratio,
            "Risk Score (J)": j_score
        }
# --- Execution ---
if __name__ == "__main__":
    try:
        engine = LETDiagnosticEngine(movement='Flexion')
        results = engine.execute_diagnostic()
        
        print("\n--- LET DIAGNOSTIC INTEGRITY REPORT ---")
        for k, v in results.items():
            print(f"{k:25}: {v:.4f}")
        print("---------------------------------------")        
    except Exception as e:
        print(f"Operational Error: {e}")
