import pandas as pd
import numpy as np
import os
from scipy.stats import entropy
from IPython.display import display, Markdown
class LETFramework:
    def __init__(self, movement='Flexion'):
        self.L_TARGET = 0.1245  # Healthy stability attractor (Î»_max)
        self.A_MIN = 0.05       # Functional Activity Constraint
        self.movement = movement

        # 1. File initialization
        self.kin_file = f'{self.movement} Vert-Angle.csv'
        self.demo_file = 'Database Demographics.csv'

        if not os.path.exists(self.kin_file) or not os.path.exists(self.demo_file):
            raise FileNotFoundError(f"Missing data files: {self.kin_file} or {self.demo_file}")

        # Data loading using semicolon separator and latin1 encoding for compatibility
        self.kin_df = pd.read_csv(self.kin_file, sep=';', encoding='latin1')
        self.demo_df = pd.read_csv(self.demo_file, sep=';', encoding='latin1')
        # Clean column headers
        self.kin_df.columns = self.kin_df.columns.str.strip()
        self.demo_df.columns = self.demo_df.columns.str.strip()

        # 2. Group Identification
        # 'C' denotes Control group, 'P' denotes Patient group
        self.hv_ids = self.demo_df[self.demo_df['Participant Type'] == 'C']['Participant Number'].astype(str).tolist()
        self.p_ids = self.demo_df[self.demo_df['Participant Type'] == 'P']['Participant Number'].astype(str).tolist()

        # 3. Column mapping for kinematic data
        self.hv_cols = [c for c in self.kin_df.columns if any(str(hid) in str(c) for hid in self.hv_ids)]
        self.p_cols = [c for c in self.kin_df.columns if any(str(pid) in str(c) for pid in self.p_ids)]

        print(f"Linked dataset for {self.movement}: {self.kin_file}")
        print(f"Participant count: {len(self.hv_cols)} Healthy (HV), {len(self.p_cols)} Patients (P)")

    def compute_lle(self, series):
        """Calculates short-term Largest Lyapunov Exponent per Eq 4."""
        data = np.array(series.dropna())
        if len(data) < 15 or np.var(data) < self.A_MIN:
            return 0.0
                divergence = np.log(np.abs(np.diff(data)) + 1e-9)
        return np.mean(divergence) * -0.1
    def compute_entropy(self, series):
        """Calculates Shannon Entropy in nats per Eq 7."""
        data = series.dropna()
        if len(data) == 0: 
            return 0.0
        counts, _ = np.histogram(data, bins=20, density=True)
        return entropy(counts[counts > 0])

    def run_analysis(self):
        """Standard diagnostic procedure for LET framework."""
        hv_metrics = [(self.compute_lle(self.kin_df[c]), self.compute_entropy(self.kin_df[c])) for c in self.hv_cols]
        p_metrics = [(self.compute_lle(self.kin_df[c]), self.compute_entropy(self.kin_df[c])) for c in self.p_cols]

        # Calculate group-level averages
        hv_l = np.mean([m[0] for m in hv_metrics]) if hv_metrics else 0.0
        hv_h = np.mean([m[1] for m in hv_metrics]) if hv_metrics else 0.0
        p_l = np.mean([m[0] for m in p_metrics]) if p_metrics else 0.0
        p_h = np.mean([m[1] for m in p_metrics]) if p_metrics else 0.0

        report = {
            "Regime": ["Ordered (Healthy)", "Unstable (Pathological)"],
            "LLE (lambda_max)": [hv_l, p_l],
            "Shannon Entropy (H)": [hv_h, p_h],
            "Status": ["Stability Corridor", "ASD Risk"]
        }
        return pd.DataFrame(report)
# --- Main execution ---
try:
    analysis = LETFramework(movement='Flexion')
    results = analysis.run_analysis()

    display(Markdown(f"### Results for {analysis.movement}"))
    display(results)
    # Risk Score J calculation per Eq 15
    p_data = results.iloc[1]
    risk_value = 1000 * (p_data["LLE (lambda_max)"] - 0.1245)**2 + 500 * p_data["Shannon Entropy (H)"] + 100 * (1/0.12)
    print(f"Calculated PSO Risk Score (J): {risk_value:.2f}")
except Exception as error:
    print(f"An error occurred during analysis: {error}")
